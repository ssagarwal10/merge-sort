//SHUBHAM AGARWAL
//130

//DAA Assignment 3

//TITLE:Design and implement Merge  Sort algorithm using Divide and Conquer method for a given input. Determine the time required to search an element.

//CODE:

#include<iostream>

using namespace std;
void mergesort(int [],int,int);
void merge(int[],int,int);
int main()
{
  int n,i;
  cout<<"\nEnter the length of the array\n";
  cin>>n;
  int arr[n];
  cout<<"\nEnter the array elements\n";
  for(i=0;i<n;i++)
  {
    cin>>arr[i];
  }

mergesort(arr,0,n-1);

cout<<"\nThe sorted array is:\n";
for(i=0;i<n;i++)
  {
    cout<<arr[i]<<endl;
  }
cout<<"\nArray without repetition:\n";
for(i=0;i<n;i++)
{
	if(arr[i]!=arr[i+1])
	{
		if(i>0)
		{
			if(arr[i-1]!=arr[i])
			{
		cout<<arr[i]<<endl;

			}
		}
		else
		{
			cout<<arr[i]<<endl;

		}
	}

}



}

void mergesort(int arr[],int l, int h)
{
  if(h>l)
  {
    mergesort(arr,l,(l+h)/2);
    mergesort(arr,((l+h)/2)+1,h);
    merge(arr,l,h);
  }
}

void merge(int arr[], int l, int h)
{
    int b[h];
    int i,j,m,k=l;
    i=l;
    j=((l+h)/2)+1;
    m=j-1;
    while (i<=m && j<=h)
    {
      if(arr[i]<arr[j])
      {
        b[k]=arr[i];
        i++;
      }
      else
      {
        b[k]=arr[j];
        j++;
      }
      k++;
    }

    if(i>m)
    {
      while(j<=h)
      {
        b[k]=arr[j];
        j++;
        k++;
      }
    }
    else
    {
      while(i<=m)
      {
        b[k]=arr[i];
        i++;
        k++;
      }
    }
    k=l;
    while(k<=h)
    {
      arr[k]=b[k];
      k++;
    }

}


//OUTPUT:

Enter the length of the array
5

Enter the array elements
3
3
1
2
4

The sorted array is:
1
2
3
3
4

Array without repetition:
1
2
4

//TIME COMPLEXITY:

For N = 1: time is a constant (denoted by 1)

Otherwise: time to mergesort N elements = time to mergesort N/2 elements plus
time to merge two arrays each N/2 elements.

Time to merge two arrays each N/2 elements is linear, i.e. N

Thus we have:

(1) T(1) = 1

(2) T(N) = 2T(N/2) + N

Next we will solve this recurrence relation. First we divide (2) by N:

(3) T(N) / N = T(N/2) / (N/2) + 1

N is a power of two, so we can write

(4) T(N/2) / (N/2) = T(N/4) / (N/4) +1
(5) T(N/4) / (N/4) = T(N/8) / (N/8) +1

(6) T(N/8) / (N/8) = T(N/16) / (N/16) +1

(7) ……
(8) T(2) / 2 = T(1) / 1 + 1

Now we add equations (3) through (8) : the sum of their left-hand sides
will be equal to the sum of their right-hand sides:

T(N) / N + T(N/2) / (N/2) + T(N/4) / (N/4) + … + T(2)/2 =

T(N/2) / (N/2) + T(N/4) / (N/4) + ….+ T(2) / 2 + T(1) / 1 + LogN

(LogN is the sum of 1s in the right-hand sides)

After crossing the equal term, we get

(9) T(N)/N = T(1)/1 + LogN

T(1) is 1, hence we obtain

(10) T(N) = N + NlogN = O(NlogN)

Hence the complexity of the MergeSort algorithm is O(NlogN).
